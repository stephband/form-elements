<!DOCTYPE html>
<!-- Literal template "/Users/stephband/Sites/form-elements/index.html.literal" -->

<html lang="en">
<head>
    <meta charset="utf-8" />
<meta name="author" content="Stephen Band" />
<meta name="description" content="Documentation for form-elements. A collection of advanced form controls published as custom elements" />
<meta name="viewport" content="width=device-width" />


<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@stephband">
<meta property="og:title" content="form-elements" />
<meta property="og:description" content="A collection of advanced form controls published as custom elements" />
<meta property="og:image" content="https://stephen.band/form-elements/card.png" />
<meta property="og:url" content="https://stephen.band/form-elements/" />


<title>form-elements</title>



<script title="load">
    document.documentElement.className += ' js loading';
    // window.addEventListener('DOMContentLoaded', () => document.documentElement.classList.remove('content-loading'));
    // Wait for other load handlers to run first - Bolt does a few things on
    // load (eg. targetable scrolls) and we want them to run before the loading
    // class is removed
    window.addEventListener('load', () => window.requestAnimationFrame(() => document.documentElement.classList.remove('loading')));
</script>


    <script title="debug">
        window.DEBUG = true;
    </script>

    <link rel="stylesheet" href="../bolt/module.css">
    <link rel="stylesheet" href="../bolt/documentation/prism-cruncher.css" />
<link rel="stylesheet" href="../bolt/documentation.css" />
<link rel="stylesheet" href="../bolt/debug.css" />


    <style>
    rotary-input {
        max-width: 10rem;
    }

    * + rotary-input,
    * + xy-input {
        margin-top: 2rem;
    }
    </style>

    
    <template id="xy-input-shadow">
        <template id="x-tick">
            <label part="x-tick tick" style="transform: translate(calc(${ data.up.toViewX(data.tick.value) }em - 50%), 1.5em);">
                <span>${ data.tick.label }</span>
            </label>
        </template>

        <template id="y-tick">
            <label part="y-tick tick" style="transform: translate(-2.75em, calc(${ data.up.toViewY(data.tick.value) }em + 50%));">
                <span>${ data.tick.label }</span>
            </label>
        </template>

        <label>
            <slot></slot>
        </label>

        <canvas>${
            this.ctx      = this.ctx || element.getContext('2d'),
            this.computed = this.computed || getComputedStyle(data.host),

            // Todo: Observers are not being registered on first render, because
            // they are protected by the paddingbox check, but then not on any
            // other render either. This is because this is a TextRenderer being
            // told to rerender, where the observers are only updated on
            // rerenders of the parent TemplateRenderer. And this is a bit of a
            // worry, because it's a hole in my thinking that I had not... well,
            // to be fair I smelled something off about the observation system,
            // I guess this is where it's coming from.
            //
            // For the moment, kick start the observation here by reading them
            // before the paddingbox check.
            data.points.map((point) => (point.x, point.y)),

            // And observe each box change (TEMP, get rid of data.box, we only
            // use it for this)
            data.box && (
                this.viewbox    = { x: data.contentbox.x * 2, y: data.contentbox.y * 2, width: data.contentbox.width * 2, height: data.contentbox.height * 2 },
                this.xGridColor = this.computed.getPropertyValue('--line-color-x').trim(),
                this.yGridColor = this.computed.getPropertyValue('--line-color-y').trim(),
                this.graphColor = this.computed.getPropertyValue('--plot-color').trim(),

                // Clears canvas as well as setting up size
                element.width  = data.paddingbox.width * 2,
                element.height = data.paddingbox.height * 2,
                //data.clear(this.ctx, { x: 0, y: 0, width: element.width, height: element.height }),

                data.drawXLines(this.ctx, this.viewbox, data.xaxis
                    .filter((line) => data.valuebox.x + data.valuebox.width >= line.value && line.value >= data.valuebox.x)
                    .map((line) => data.toRatioX(line.value)),
                    this.xGridColor
                ),

                data.drawYLines(this.ctx, this.viewbox, data.yaxis
                    .filter((line) => data.valuebox.y + data.valuebox.height >= line.value && line.value >= data.valuebox.y)
                    .map((line) => data.toRatioY(line.value)),
                    this.yGridColor
                ),
/*
                data.xScale === 'linear' ?
                    data.points.forEach((point) => data.drawCrosshair(this.ctx, this.viewbox, 28, {
                        x: data.toRatioX(point.x),
                        y: data.toRatioY(point.y)
                    }, this.graphColor)) :
                    data.drawCurve(
                        this.ctx,
                        this.viewbox,
                        data.points.map((point, i) => ({
                            x: data.toRatioX(point.x),
                            y: data.toRatioY(point.y)
                        })).sort(by(get('x'))),
                        this.graphColor
                    ),
*/
                data.drawAudioEnvelope(this.ctx, this.viewbox, data.valuebox, data.points, '#440066')
            ), ''
        }</canvas>

        <!-- SVG must be made to cover the available space else the shapes are not clickable in Safari -->
        <svg viewbox="${ data.rangebox[0] } ${ data.rangebox[1] + data.rangebox[3] } ${ data.rangebox[2] } ${ -data.rangebox[3] }">
            <defs>
                <linearGradient id="handle-gradient" x1="0" x2="0" y1="0" y2="1">
                    <stop class="stop-1" offset="0%"/>
                    <stop class="stop-2" offset="100%"/>
                </linearGradient>

                <line part="${ data.part }" x1="${ data.x1 }" x2="${ data.x2 }" y1="${ data.y1 }"  y2="${ data.y2 }" id="line-def"></line>

                <circle part="handle" class="control control-handle control-point" cx="${ data.up.toViewX(data.point.x) }" cy="${ data.up.toViewY(data.point.y) }" r="0.5" data-index="${ data.index }" id="control-def">
                    <title>${data.point.label} ${data.point.x && data.point.x.toFixed(2)}, ${data.point.y && data.point.y.toFixed(2)} ${data.point.type}</title>
                </circle>
            </defs>

            <!--
            ${ data.yaxis
            .filter((line) => data.valuebox.y + data.valuebox.height >= line.value && (
                data.yScale.startsWith('log') ? line.value === data.valuebox.y || line.value > data.valuebox.y && line.value >= ({
                    'logarithmic-24dB': (data.valuebox.y + data.valuebox.height)/2/2/2/2/2/2/2,
                    'logarithmic-30dB': (data.valuebox.y + data.valuebox.height)/2/2/2/2/2/2/2/2,
                    'logarithmic-36dB': (data.valuebox.y + data.valuebox.height)/2/2/2/2/2/2/2/2/2,
                    'logarithmic-48dB': (data.valuebox.y + data.valuebox.height)/2/2/2/2/2/2/2/2/2/2,
                    'logarithmic-60dB': (data.valuebox.y + data.valuebox.height)/2/2/2/2/2/2/2/2/2/2/2/2,
                    'logarithmic-72dB': (data.valuebox.y + data.valuebox.height)/2/2/2/2/2/2/2/2/2/2/2/2/2/2,
                    'logarithmic-96dB': (data.valuebox.y + data.valuebox.height)/2/2/2/2/2/2/2/2/2/2/2/2/2/2/2/2/2/2
                })[data.yScale] :
                line.value >= data.valuebox.y
            ))
            .map((line) => include(this.node.getRootNode().getElementById('line-def'), {
                part: 'y-line line',
                x1: data.toViewX(data.valuebox.x),
                x2: data.toViewX(data.valuebox.x + data.valuebox.width),
                y1: data.toViewY(line.value),
                y2: data.toViewY(line.value)
            })) }
            -->

            ${ data.points.map((point, index) => include(this.node.getRootNode().getElementById('control-def'), {
                up: data,
                point,
                index
            })) }
        </svg>

        ${ data.xaxis
        .filter((tick) => tick.label && data.valuebox.x + data.valuebox.width >= tick.value && tick.value >= data.valuebox.x)
        .map((tick, index) => include(this.node.getRootNode().getElementById('x-tick'), { up: data, tick })) }

        ${ data.yaxis
        .filter((tick) => tick.label && data.valuebox.y + data.valuebox.height >= tick.value && (
            data.yScale.startsWith('log') ? tick.value === data.valuebox.y || tick.value > data.valuebox.y && tick.value >= ({
                'logarithmic-24dB': (data.valuebox.y + data.valuebox.height)/2/2/2/2/2,
                'logarithmic-30dB': (data.valuebox.y + data.valuebox.height)/2/2/2/2/2/2,
                'logarithmic-36dB': (data.valuebox.y + data.valuebox.height)/2/2/2/2/2/2/2,
                'logarithmic-48dB': (data.valuebox.y + data.valuebox.height)/2/2/2/2/2/2/2/2/2,
                'logarithmic-60dB': (data.valuebox.y + data.valuebox.height)/2/2/2/2/2/2/2/2/2/2,
                'logarithmic-72dB': (data.valuebox.y + data.valuebox.height)/2/2/2/2/2/2/2/2/2/2/2/2,
                'logarithmic-96dB': (data.valuebox.y + data.valuebox.height)/2/2/2/2/2/2/2/2/2/2/2/2/2/2/2/2/2
            })[data.yScale] :
            tick.value >= data.valuebox.y
        ))
        .map((tick, index) => include(this.node.getRootNode().getElementById('y-tick'), { up: data, tick })) }
    </template>

</head>

<body class="docs-grid grid 3x-grid @1-6x-grid @2-9x-grid" style="align-content: start;">
    <header class="x1 3x @1-x3 @1-4x @2-x4">
        <h1>Form elements</h1>
        <p>A collection of advanced form controls published as custom elements.</p>
    </header>

    <div class="x1 3x @1-x3 @1-4x @2-x4">
        <h2>&lt;range-input&gt;</h2>
        <a href="./range-input">&lt;range-input&gt;</a>
    </div>

    <range-input class="x1 y2 3x" name="scale" min="-1" max="1" ticks="-1 -0.8 -0.6 -0.4 -0.2 0 0.2 0.4 0.6 0.8 1" value="0">Scale</range-input>

    <div class="x1 3x @1-x3 @1-4x @2-x4">
        <h2>&lt;rotary-input&gt;</h2>
        <a href="./rotary-input">Documentation</a>
    </div>

    <rotary-input class="x2 2x y3" name="pan" min="-1" max="1" ticks="-1 -0.8 -0.6 -0.4 -0.2 0 0.2 0.4 0.6 0.8 1">Pan</rotary-input>

    <div class="x1 3x @1-x3 @1-4x @2-x4">
        <h2>&lt;xy-input&gt;</h2>
        <a href="./xy-input">Documentation</a>
    </div>

    <xy-input class="x1 y4 3x">Envelope</xy-input>

    <script type="module">
    import '../bolt/module.js';
    import '../bolt/documentation.js';
</script>

    <script type="module">
        import RangeInput  from './range-input.js';
        import RotaryInput from './rotary-input.js';
        import XYInput     from './xy-input.js';
    </script>
</body>
